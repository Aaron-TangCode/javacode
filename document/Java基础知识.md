# Java基础知识

## 基础语法

### 数据类型

Java 是一种**静态类型**语言，它包括了两种数据类型：

- 基本数据类型（Primitive Data Types）：int, char, byte, short, long, float, double, boolean。
- 引用数据类型（Reference Data Types）：类（Class）、接口（Interface）和数组（Array）。

**补充**

1、其中String，Integer，Long这些都属于类，因此属于「引用数据类型」

2、基本数据类型占用的字节

| 基本数据类型 | 字节数 | 数据范围                                 |
| ------------ | ------ | ---------------------------------------- |
| int          | 4      | -2147483648~2147483647                   |
| char         | 2      | 0~65535                                  |
| byte         | 1      | -128~127                                 |
| short        | 2      | -32768~31767                             |
| long         | 8      | -9223372036854775808~9223372036854775807 |
| float        | 4      | 1.4e-45f ~ 3.4028235e+38f                |
| double       | 8      | 4.9e-324 ~ 1.7976931348623157e+308       |
| boolean      | 1      | true / false                             |



### 变量

Java 中的变量必须先声明后使用，声明时需要指定变量的数据类型。

变量的命名规则

1. **字母数字字符和下划线**：变量名可以包含字母、数字、下划线（_）和美元符号（$），但不能以数字开头。
2. **区分大小写**：Java是区分大小写的编程语言，这意味着`variable`和`Variable`是两个不同的变量名。
3. **不可以是关键字**：变量名不能使用Java的保留关键字。例如，你不能将变量命名为`int`或`class`。
4. **长度限制**：理论上，变量名的长度没有限制，但为了代码的可读性和可维护性，应该使用适当长度的变量名。
5. **Unicode字符**：变量名可以使用任何Unicode字符，但不推荐使用，因为它会使代码难以阅读和理解。

此外，虽然不是硬性规则，还有一些命名约定应该遵守，以提高代码的可读性和一致性：

- **驼峰命名法**：在Java中，变量名通常采用所谓的驼峰命名法。对于局部变量和实例变量，通常使用小驼峰式命名法（lowerCamelCase），即变量名的第一个单词首字母小写，之后每个单词的首字母都大写，比如`localVariable`、`studentName`。
- **有意义的名称**：变量名应该有描述性，能够表明变量的用途，如`employeeSalary`，`totalCount`。
- **常量命名**：如果变量是常量（即使用`final`关键字修饰的变量），则应该全部使用大写字母，并且单词之间用下划线分隔，如`MAX_CODE`。

例子：

```java
1int count;      // 符合规则，使用小写字母开头
2String myName;  // 符合规则，使用小驼峰式命名法
3final double PI_VALUE = 3.14159;  // 符合规则，常量全部大写，单词间用下划线分隔
```



### 修饰符

Java 提供了多种修饰符来设置类、变量和方法的访问规则和其他功能。主要分为访问控制修饰符（public, private, protected）和非访问控制修饰符（static, final, abstract 等）

1. **访问修饰符**：在Java中，访问权限修饰符决定了类、变量、方法和构造器的可访问性。主要有四种访问修饰符：
   - `public`：公开的，可以被任何其他类访问。
   - `protected`：受保护的，可以被同一个包内的类以及不同包中的子类访问。
   - `default`（没有修饰符）：默认访问，仅能被同一个包内的类访问。
   - `private`：私有的，只能在定义它们的类内部访问。
2. **非访问修饰符**：这些修饰符不控制访问级别，但提供了其他功能。主要包括：
   - `static`：静态修饰符，用于创建类的静态成员，它们可以在未实例化类的情况下访问。
   - `final`：表示最终的，可以修饰类、方法和变量。修饰类时，表明类不能被继承；修饰方法时，表明方法不能被重写；修饰变量时，表示变量的值一旦赋值后不能被改变。
   - `abstract`：抽象的，用于创建抽象类和抽象方法。抽象类不能被实例化，抽象方法必须由子类提供实现。
   - `synchronized`：表示同步，用于多线程编程中，可以用于方法或代码块。加了此关键字的方法或代码块在任何时刻只能有一个线程执行。
   - `transient`：瞬态的，用在序列化过程中，表示某个属性不需要序列化。
   - `volatile`：易变的，用于告知虚拟机该变量可能会被多个线程同时访问，从而确保每次都从主内存中读取变量值。
3. **类成员修饰符**：类成员包括变量、方法和构造器，它们可以使用访问修饰符和非访问修饰符。
4. **类修饰符**：用于修饰类的声明。除了上述修饰符外，还可以使用`strictfp`关键字，它可以保证类中的浮点运算在不同平台上结果一致。
5. **常见的访问修饰符组合及其含义**：比如`public static final`经常用来定义常量。
6. **修饰符的规则和最佳实践**：比如使用最小访问原则，即只为其他类提供必要的访问权限，以及理解哪些修饰符组合是合法的（例如，方法不能同时是`abstract`和`final`）



### 运算符

Java 支持多种运算符来对数据进行操作，包括算术运算符（+,-,*,/,% 等）、关系运算符（==,!=,>,<,>=,<=）、逻辑运算符（&&,||, !）、赋值运算符（=, +=, -= 等）和位运算符。

1. **算术运算符**：
   - 加法（`+`）
   - 减法（`-`）
   - 乘法（`*`）
   - 除法（`/`）
   - 取余（模运算）（`%`）
   - 自增（`++`）
   - 自减（`--`）
2. **关系运算符**：
   - 等于（`==`）
   - 不等于（`!=`）
   - 大于（`>`）
   - 小于（`<`）
   - 大于等于（`>=`）
   - 小于等于（`<=`）
3. **逻辑运算符**：
   - 逻辑与（`&&`）
   - 逻辑或（`||`）
   - 逻辑非（`!`）
4. **位运算符**：
   - 位与（`&`）
   - 位或（`|`）
   - 位异或（`^`）
   - 位非（取反）（`~`）
   - 左移（`<<`）
   - 右移（`>>`）
   - 无符号右移（`>>>`）
5. **赋值运算符**：
   - 简单赋值（`=`）
   - 加法赋值（`+=`）
   - 减法赋值（`-=`）
   - 乘法赋值（`*=`）
   - 除法赋值（`/=`）
   - 取余赋值（`%=`）
   - 左移赋值（`<<=`）
   - 右移赋值（`>>=`）
   - 位与赋值（`&=`）
   - 位或赋值（`|=`）
   - 位异或赋值（`^=`）
6. **条件运算符**（也称为三元运算符）：
   - `? :`，用于简单的条件赋值，形式为 `条件 ? 表达式1 : 表达式2`，如果条件为真，则结果为表达式1，否则为表达式2。
7. **类型相关的运算符**：
   - 类型转换运算符，例如 `(int)`, `(double)` 等，用于将表达式显式转换为其他类型。
   - `instanceof`，用于检查一个对象是否是特定类的实例。
8. **运算符的优先级和结合性**：
   - 理解不同运算符之间的优先级关系，比如乘除的优先级高于加减。
   - 理解同一优先级运算符的计算顺序，也就是结合性，比如赋值运算符的结合性是从右到左。
9. **运算符的重载**：
   - Java中唯一支持运算符重载的是加号（`+`），主要用于字符串的连接

**注意点**

- =和==的区别





### 控制流程语句

控制程序流程的语句，包括条件语句（if-else, switch-case）和循环语句（for, while, do-while）等

1. **条件语句**：这些语句根据条件的真假来决定程序的执行路径。
   - `if`语句：用于基于条件执行代码块。
   - `if...else`语句：当`if`条件为真时执行一个代码块，否则执行`else`部分的代码。
   - `else if`链：用于创建多个条件分支。
   - `switch`语句：选择多个代码块之一去执行。`switch`可以使用`case`语句来定义不同的分支，以及`default`来定义当没有匹配的`case`时的默认行为。
2. **循环语句**：这些语句允许代码重复执行，直到满足某个条件。
   - `while`循环：当条件为真时，循环会一直执行。
   - `do-while`循环：与`while`循环类似，但保证至少执行一次循环体，然后再检查条件。
   - `for`循环：允许在循环声明中初始化变量，定义循环条件以及更新循环变量。
   - `for-each`循环：Java 5引入的增强型`for`循环，用于遍历数组或集合中的元素。
3. **跳转语句**：这些语句用于改变执行流程，跳过某些代码的执行。
   - `break`：立即退出最近的包围`switch`语句或循环。
   - `continue`：跳过当前循环的剩余部分，并开始下一个循环迭代。
   - `return`：退出当前方法，并可选地返回一个值（如果方法不是`void`类型的话）。
4. **异常处理**：用于处理程序运行时可能出现的意外情况或错误。
   - `try`块：包围可能会抛出异常的代码。
   - `catch`块：捕捉异常并定义如何处理它们。
   - `finally`块：无论是否捕捉到异常，`finally`块中的代码总是会被执行。
   - `throw`：用于手动抛出异常。
   - `throws`：在方法签名中声明可能抛出的异常。
5. **控制流程的最佳实践**：理解如何有效地使用控制流程语句，例如：
   - 避免过度使用`break`和`continue`，因为它们可能会使循环逻辑变得难以跟踪。
   - 使用有意义的条件表达式以提高代码的可读性。
   - 在`switch`语句中不要忘记`break`，以避免无意的“穿透”到下一个`case`。
   - 尽量使循环和条件语句简单，避免嵌套过深，从而提高代码的可理解性。
   - 在适当的时候使用异常处理来增强程序的健壮性。



### 数组

定义：数组是用来存储固定大小的同类型元素的集合。

1. **数组的基本概念**：
   - 定义：数组是一种存储**固定**大小的**同类型**元素的**顺序**集合。
   - 数组是一个对象。
2. **数组的声明、创建和初始化**：
   - 如何声明数组，例如 `int[] myArray;`。
   - 如何创建数组实例，例如 `myArray = new int[10];`，这里分配了一个可以存储10个整数的空间。
   - 如何同时声明和创建数组，例如 `int[] myArray = new int[10];`。
   - 如何对数组进行初始化，例如 `int[] myArray = {1, 2, 3, 4, 5};`。
   - 数组一旦创建后，大小就是固定的。
3. **数组元素的访问和修改**：
   - 如何通过下标（索引）访问数组元素，例如 `int x = myArray[0];`。
   - 如何通过下标修改数组元素的值，例如 `myArray[0] = 10;`。
   - **数组下标是从0开始的，最大的索引是数组长度减1**。
4. **数组的特性和属性**：
   - 如何使用数组的`length`属性来获取数组的大小，例如 `int size = myArray.length;`。
   - Java数组在内存中的连续存储特性
5. **数组的遍历**：
   - 使用传统的`for`循环遍历数组。
   - 使用增强的`for`循环（也称为`for-each`循环）来遍历数组，例如 `for(int element : myArray) {...}`。
6. **多维数组**：
   - Java支持多维数组（数组的数组），例如二维数组 `int[][] matrix;`。
   - 如何声明、创建和初始化多维数组。
7. **常见操作和算法**：
   - 常见的数组操作，如排序、搜索、复制、反转等。
   - 如何使用Java标准库中的`Arrays`类进行数组操作，例如 `Arrays.sort(myArray);`。
8. **数组和函数**：
   - 如何将数组作为参数传递给函数。
   - 如何从函数返回数组。
9. **数组的局限性和替代方案**：
   - 数组的局限性，例如无法动态改变大小、缺乏某些方便的操作方法等。
   - Java集合框架（如`ArrayList`），它提供了更加灵活的数据结构。





### 方法

方法是一组用来执行特定任务的语句的集合。方法可以带有参数并且可以返回值。

1. **方法的定义和调用**：

   - 方法是一段具有特定功能的代码块，可以被调用执行。
   - 如何定义一个方法，包括指定方法名、返回类型、参数列表和方法体。

   **示例**：

   ```java
   1// 定义一个方法，计算两个整数的和
   2public int add(int num1, int num2) {
   3    return num1 + num2;
   4}
   5
   6// 调用方法
   7public static void main(String[] args) {
   8    MyClass myClass = new MyClass();
   9    int result = myClass.add(5, 10);
   10    System.out.println("Sum is: " + result);
   11}
   ```

2. **参数传递**：

   - 如何向方法传递参数。
   - java中参数传递是按值传递，对于基本数据类型传递的是值副本，对于对象传递的是引用副本。

   **示例**：

   ```java
   1public void greet(String name) {
   2    System.out.println("Hello, " + name);
   3}
   4
   5// 调用方法
   6public static void main(String[] args) {
   7    MyClass myClass = new MyClass();
   8    myClass.greet("Alice");
   9}
   ```

3. **方法重载（Overloading）**：

   - 定义：多个具有相同名称但参数列表不同的方法。

   参数列表不同可以体现在以下几个方面：

   1. **参数的数量不同**：方法的参数个数可以不同。
      - 示例：`void display(int a)` 和 `void display(int a, int b)`
   2. **参数的类型不同**：即使参数的数量相同，但数据类型不同，也构成方法重载。
      - 示例：`void display(int a)` 和 `void display(String a)`
   3. **参数的顺序不同**：参数的数据类型顺序不同，即使它们的数量和类型相同。
      - 示例：`void display(int a, String b)` 和 `void display(String a, int b)`

   以下是一个具体的Java方法重载的例子：

   ```java
   public class OverloadingExample {
   
       // 方法1：一个参数
       public void print(String content) {
           System.out.println(content);
       }
   
       // 方法2：两个参数，类型相同
       public void print(String content1, String content2) {
           System.out.println(content1 + ", " + content2);
       }
   
       // 方法3：两个参数，类型不同
       public void print(String content, int repeat) {
           for (int i = 0; i < repeat; i++) {
               System.out.println(content);
           }
       }
   
       // 方法4：两个参数，顺序不同
       public void print(int repeat, String content) {
           for (int i = 0; i < repeat; i++) {
               System.out.print(content);
           }
           System.out.println();
       }
   
       public static void main(String[] args) {
           OverloadingExample example = new OverloadingExample();
           example.print("Hello World");           // 调用方法1
           example.print("Hello", "World");        // 调用方法2
           example.print("Hello World", 3);        // 调用方法3
           example.print(3, "Hello World");        // 调用方法4
       }
   }
   
   ```

4. **递归方法**：

   - 定义：方法自己调用自己，这称为递归。

   **示例**：

   ```java
   1public int factorial(int n) {
   2    if (n <= 1) {
   3        return 1;
   4    }
   5    return n * factorial(n - 1);
   6}
   ```

5. **返回值**：

   - 方法可以有返回值，也可以没有返回值（使用`void`）。
   - 如何使用`return`语句从方法返回值。

   **示例**：

   ```java
   1public boolean isEven(int number) {
   2    return number % 2 == 0;
   3}
   ```

6. **变长参数（Varargs）**：

   - 如何定义接受任意数量参数的方法。

   **示例**：

   ```java
   1public void printNumbers(int... numbers) {
   2    for (int number : numbers) {
   3        System.out.print(number + " ");
   4    }
   5    System.out.println();
   6}
   ```

7. **作用域**：

   - 局部变量的作用域限制在方法内部。

   **示例**：

   ```java
   1public void testScope() {
   2    int localVar = 5; // localVar 的作用域限于 testScope 方法内
   3    System.out.println(localVar);
   4}
   ```



### 类与对象

Java 是一种面向对象的编程语言，类（Class）是对象的模板，对象（Object）是类的实例。

```java
// 定义一个简单的类
2public class Person {
3    // 字段定义（属性）
4    private String name;
5    private int age;
6
7    // 构造方法
8    public Person(String name, int age) {
9        this.name = name;
10        this.age = age;
11    }
12
13    // 方法定义（行为）
14    public void introduce() {
15        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
16    }
17
18    // Getter 和 Setter 方法
19    public String getName() {
20        return name;
21    }
22
23    public void setName(String name) {
24        this.name = name;
25    }
26
27    public int getAge() {
28        return age;
29    }
30
31    public void setAge(int age) {
32        this.age = age;
33    }
34
35    // 静态方法示例
36    public static void sayHello() {
37        System.out.println("Hello!");
38    }
39}
40
41// 类的使用
42public class Main {
43    public static void main(String[] args) {
44        // 创建对象
45        Person person1 = new Person("Alice", 25);
46        Person person2 = new Person("Bob", 30);
47
48        // 调用对象的方法
49        person1.introduce();
50        person2.introduce();
51
52        // 访问静态方法
53        Person.sayHello();
54    }
55}
```

### 继承

Java 支持类之间的继承，子类可以继承父类的属性和方法，但只能**单继承**



### 接口

接口是抽象方法的集合，类可以通过实现接口来继承接口中的抽象方法，**允许实现多个接口**





### 异常处理

Java 提供了异常处理机制，包括 try-catch 语句和 throw 语句，用于处理程序运行时的异常情况。

todo 提供Error和Exception的关系图



### 包（Package）

包是用来组织类的一种方式，可以将功能相似的类和接口组织在一起。



### 多态

什么是多态？

多态有哪些特点？

使用多态的场景？



### 泛型

什么是泛型？

泛型的使用场景？



### 反射

反射的使用场景？

什么是反射？



### 序列化

什么是序列化？

什么场景需要序列化？





## 什么是静态类型语言？

### 定义

Java 被称为一种静态类型语言（statically typed language），这意味着所有的变量和表达式的类型在编译时期就已经确定，并且在整个程序运行期间不会改变。这与动态类型语言（dynamically typed languages）不同，后者允许变量的类型在程序运行时改变或者在声明时不显式指定类型。

### 静态类型语言有什么特点

1. 类型检查：编译器在编译阶段就会对代码进行类型检查，如果类型不匹配，编译器会报错。例如，如果你尝试将一个字符串赋值给一个整型变量，编译器会抛出错误。

2. 变量声明：在 Java 中，每个变量在使用前都需要声明，并且在声明时指定其数据类型。例如：

   ```
   1int number = 5; // 显式声明number是int类型
   ```

3. 性能：静态类型语言通常在性能上有优势，因为编译器对类型的了解使得可以生成更优化的机器码。

4. 可读性和可维护性：静态类型有助于提高代码的可读性和可维护性。因为数据类型是显式声明的，所以读代码的人可以更容易地理解每个变量的预期用途。

5. 工具支持：静态类型语言通常提供更好的开发工具支持，如自动完成、重构工具和更严格的编码规范检查，因为编译器在编码时就了解了代码结构。

### 对比：动态类型语言有哪些特点的特性

1. 类型推断：动态类型语言依赖于运行时来确定实际的数据类型，并且在声明变量时不一定需要指定数据类型。
2. 灵活性：动态类型语言通常更灵活，因为它们在运行时允许类型更改或不要求在初始声明时就确定类型。
3. 编写速度：动态类型语言可能会加快初期开发速度，因为程序员可以快速编写代码，而不需要花时间声明类型。

### 例子

举例来说，对比 **Python（一种动态类型语言）和 Java（一种静态类型语言）**：

```
1# Python (动态类型)
2number = "123"      # 初始为字符串
3number = 123        # 同一变量可以改变类型，赋值为整数
1// Java (静态类型)
2String number = "123"; // 显式声明为String类型
3number = 123;          // 编译错误，不能将整数赋值给字符串类型的变量
```

在 Java 中，类型是在编译时确定的，并且一旦声明，变量的类型就不能更改。这有助于捕捉错误并提高代码的稳定性，但也使得语言在某些方面不如动态类型语言灵活。

